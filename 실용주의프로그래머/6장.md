# TIL (2022.03.30)

### DAY 10

**🔖  오늘 읽은 범위 : 6장 동시성**

---

<aside>
💡 **책에서 기억하고 싶은 내용**

</aside>

- 동시성: 둘 이상의 코드 조각이 실행될 때 동시에 실행 중인 것처럼 행동하는 것
- 병렬성: 실제로 동시에 실행되는 것

- 동시성을 얻으려면 코드의 다른 부분으로 실행을 전환할 수 있는 환경에서 코드를 구동해야 한다. 보통은 파이버나 스레드, 프로세스 등을 사용해서 동시성을 구현한다.
- 병렬성을 얻으려면 두 가지 일을 동시에 할 수 있는 하드웨어가 필요하다. CPU, 네트워크로 연결된 여러 대의 컴퓨터 등.
- 동시성은 소프트웨어 동작 방식이고, 병렬성은 하드웨어가 하는 것이다.

- 동시성은 필수다. 세상은 비동기적이기 때문이다.
- 또 다른 결합이 있다. 시간적 결합(temporal coupling)은 당면한 문제 해결에 꼭 필요하지 않은 일 처리 순서를 코드가 강제할 때 생긴다.

- 액터 모델은 프로세스들이 독립적으로 수행되며 서로 데이터를 공유하지 않는다.

### Topic 33 시간적 결합 깨트리기

- 시간에서 동시성과 순서를 신경 써야 한다.
- 메서드 A는 언제나 반드시 B보다 먼저 호출해야 한다. → 이런 접근 방법은 그다지 유연하지 않고 현실과도 동떨어져 있다.
- 우리는 동시성을 확보해야 한다.
- 설계 과정의 일환으로 애플리케이션의 작업 흐름을 모델화하고 분석하는 작업이 필요하다.
- 우리는 동시에 일어나도 되는게 뭐고 반드시 순서대로 일어나야 하는 건 어떤 것인지 찾아내길 원한다.
- 활동 다이어그램(activity diagram)을 기록해라. 동시에 수행할 수 있는데도 아직 동시에 하고 있지 않은 활동들을 찾아내서 병렬성을 극대화할 수 있다.
- 가장 이상적인 것은 비교적 독립적인 부분 작업들이다. 다른 부분 작업을 기다릴 필요 없이 진행할 수 있으면 좋다.

### Topic 34 공유 상태는 틀린 상태

- 공유 상태는 틀린 상태다.
- 세마포어는 단순히 한 번에 한 사람만 가질 수 있는 무언가다.
- 세마포어를 얻지 못한 쪽은 세마포어를 얻을 수 있을 때까지 멈춰 있는다. 즉, 기다린다.
- 이 접근 방식의 문제는 접근하는 모든 사람이 빠짐없이 세마포어를 사용해야만 제대로 동작한다는 것이다.
- 리소스를 트랜잭션으로 관리하라.
- 불규칙한 실패는 동시성 문제인 경우가 많다.

### Topic 35 액터와 프로세스

- `액터`와 `프로세스`를 사용하면 흥미로운 방식으로 동시성을 구현할 수 있다. 공유 메모리 접근을 동기화하느라 고생할 필요도 없다
- `액터`는 자신만의 비공개 지역 상태 (state)를 가진 독립적인 가상 처리 장치 (virtual processor) 다.
- `프로세스`는 본래 더 일반적인 가상 처리기로, 보통 운영 체제가 동시성을 지원하기 위하여 구현한다.
- 액터는 언제나 동시성을 띤다
- 공유 상태 없는 동시성을 위하여 액터를 사용하라.
- 액터를 관리하는 것이 하나도 없다.
- 시스템이 저장하는 상태는 오직 메시지 그리고 각 액터의 지역 상태뿐이
다.
- 모든 메시지는 일방향이다.
- 액터는 각 메시지를 끝날 때까지 처리하고 중간에 다른 일을 하지 않는다. 즉, 한 번에 하나의 메시지만 처리한다.

<aside>
  
  🤔  **오늘 읽은 소감**

</aside>

- 활동 다이어그램 예시가 좋았다. 프로그래밍 할 때 생각해 보지 못한 부분인데 의식적으로 동시에 처리할 수 있는 것을 고민해서 코딩해야 겠다는 생각을 하게 됐다.
- 동시성 문제를 아직 제대로 겪어보지 못했는데 관련해서 좀 더 공부를 해야 겠다고 생각했다.
- 병렬성과 동시성에 대해서 개념을 좀 더 확실히 알게 된 거 같다.
