# 독학사 - 운영체제

1. 운영체제 개요
    1. 사용자가 프로그래밍한 응용 프로그램은 일반 응용 프로그램이라 하지 운영체제가 아니다.
    2. 운영체제는 컴퓨터 주기억장치 안에 상주한다.
    3. 운영체제 서브시스템 - 기억장치 관리자, 프로세스 관리자, 장치 관리자, 파일 관리자
    4. 운영체제 종류 - 대화형(interactive), 실시간(realtime), 일괄처리(batch processing)
    5. 누가 주기억장치 어느 부분을 이용하는지 계속해서 알기 위해 테이블을 작성하는 관리자는 기억장치  관리자.
    6. 일괄처리 시스템 → 시분할 시스템 → 다중모드 시스템 → 분산처리 시스템
    7. 제4세대 : 컴퓨터 네트워크, 온라인 처리기법, 분산 시스템
    
2. 컴퓨터 시스템 개요
    1. 폴링 : 임의의 장치가 독립적인 기능을 하는 다른 장치의 상태를 검사할 수 있도록 허가하는 기술, CPU가 각각의 주변장치들을 연속적으로 순환하면서 인터럽트 요청이 발생했는지 수시로 체크하는 방법이다.
    2. 직접 접근 기억장치 : 정보의 저장위치에 관계 없이 임의의 주소에 직접 접근해 정보를 읽고 기록함
    3. 인터리빙 : 독립된 Modular Memory를 2개 이상으로 나눠 연결하고 CPU가 각각의 독립된 Modular Memory를 번갈아 가면서 연속적으로 액세스하도록 구현함으로써 CPU의 처리 속도에 비해 사이클 타임이 오래 걸리는 기억장치의 접근 시간을 줄이는 기법
    4. 채널 : 컴퓨터시스템의 메인 프로세서와 독립적으로 입출력을 다루기 위해 만들어진 용도의 시스템
    5. 명령어 실행 주기 - 실행 사이클, 인출 사이클, 간접 사이클, 인터럽트 사이클
    
3. 주기억장치 관리
    1. 페이지 교체기법
        1. LFU : 사용 횟수가 가장 적은 페이지를 교체
        2. FIFO : 가장 먼저 들어온 페이지를 먼저 교체
        3. LRU : 최근에 가장 오랫동안 사용하지 않은 페이지 교체
        4. 참고) SJF는 CPU 스케줄링 기법이다.
    2. 주기억장치의 크기가 8MB일 때 페이지 크기가 1KB라면 이 주기억장치에 놓일 수 있는 페이지 수는?
        1. 8MB = 8 * 1024KB로 이를 페이지 크기인 1KB로 나누면 8,192, 약 8,000개의 페이지 수이다.
    3. static partiton : 사용자의 프로그램들이 수행하기 전에 미리 주기억장치를 partition으로 나누고 준비상태 큐에서 프로그램을 각 영역에 할당해 실행하는 기법
    4. 단일 열(stream) 일괄처리 시스템 : 한 작업으로부터 다른 작업으로서의 전환을 쉽게 해서 처리량을 증가시키기 위해 개발됨, 준비시간과 철거시간을 줄임
    5. 내부 단편화: 고정분할 방식에서 똑같이 나눠진 메모리 공간에 작은 조각이 발생하는 것, 주기억장치에 프로그램이나 데이터를 배치한 후 남는 공간을 의미한다.
    6. 외부 단편화 : 기억장소의 크기가 작아 배치시키지 못하고 남는 공간을 의미한다.
    7. 94p의 20번 문제 - 외부 단편화, 내부 단편화 문제 참고
    
4. 가상기억장치 관리
    1. 가상기억장치
        1. 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소변환 작업이 필요하다
        2. 블록 단위로 나눠 사용하므로 연속 할당방식에서의 단편화를 해결할 수 있어 주기억장치의 이용률을 높일 수 있다
        3. 가상기억장치는 주기억장치의 용량보다 더 큰 프로그램을 실행하기 위해 사용한다.
    2. 주기억장치의 용량을 극복하기 위한 방법
        1. 대용량 주기억장치 사용, paged 기억장치 운영, segmented 기억장치 운영
        2. (참고) 캐시메모리 사용은 속도를 극복하기 위한 목적이다
    3. 프로그램에 의해 요구된 메모리양이 이용할 수 있는 메모리양을 초과할 때 해결하는 기법
        1. paging, segmentation, dynamic loading
    4. 직접사상에 의한 페이지 주소변환
        1. 페이지 테이블의 시작 주소는 PTBR(Page Table Base Register)에 기록한다.
        2. 원하는 데이터에 접근하기 위해서는 페이지 테이블과 데이터에 대해 각각 한 번씩 주기억장치에 접근해야 하므로 접근시간이 길다.
        3. 모든 페이지 사상표는 주기억장치나 캐시 기억장치에 보존된다. 
        4. 가상주소 <페이지번호, 변위>에서 페이지 번호에 대응되는 페이지 테이블의 엔트리에 접근해 frame 기준주소를 채취한 후 변위를 접속해 실제주소를 생성해야 한다.
    5. 연관사상은 빠른 주소변환을 수행하기 위해 고속의 연관기억장치를 사용해 페이지 사상표 전체를 넣는 방법으로 가장 가상기억장치를 사용할 때 주소변환을 빠르게 하기 위한 기법 중 하나로, 주기억장치보다 약 10배의 빠른 주소변환이 가능하지만 비용이 많이 드는 결점이 있다.
    6. 가상주소가 발생하면 먼저 TLB(Translation Lookside Buffer)에서 검색하고, 만약 대응되는 테이블 엔트리를 찾지 못하면, 주기억장치 내 페이지 테이블을 참조한다.
    7. 페이지 테이블의 일부는 연관기억장치인 TLB에 유지하고 나머지 부분은 주기억장치 내에서 테이블로 유지한다.
    8. 정보를 블록으로 분류하는 시스템은 여러 가상기억장치의 블록들이 주기억장치 어느 곳에 위치하는지 관리하기 위해서는 블록사상(block mapping)이 필요하다.
    9. 모든 프로세스는 보조기억장치와 주기억장치 내의 시스템에 의해 유지되는 블록사상 테이블을 갖고 있다.
    10. 페이지 사상 테이블 - 페이지 존재 비트, 보조기억장치 주소, 페이지 프레임 번호
    11. 페이지/세그먼트 혼용기법 - 세그먼트 번호 s, 페이비 번호 p, 변위값 d
    12. 121p의 14번, 15번 문제는 책을 참고하기. 실제 물리 주소는 r = p’ + d, 시스템의 평균 내부 단편화 크기는 일반적으로 페이지 크기의 절반이다. 
    13. 요구 페이지 호출기법에서는 참조요구에 의해 페이지를 호출하므로 주기억장치와 보조기억장치에 옮겨진 페이지들이 모두 프로세스에 의해 실제로 참조된다.
    14. 클록 페이지 교체기법 : 원형 리스트를 사용해 페이지를 배열시켜 놓는 페이지 교체기법
    15. 시간 국부성 : 프로세스가 실행되면서 처음 참조된 하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상으로, 한 번 참조된 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음을 의미한다. Loop, 스택, sub routine, counting, totaling에 사용되는 변수에서 자주 이뤄진다.
    16. 작은 페이지는 외부 단편화가 증가하고, 큰 페이지는 내부 단편화가 증가한다.
    17. Working Set : 가상기억장치 관리기법에서 페이지 부재율을 감소시키기 위한 것으로 프로그램의 Locality 특징을 이용한다. 페이지 폴트를 감소시키기 위해 Denning이 제안한 시스템으로 하나의 프로세스가 자주 참조하는 페이지들의 집합이다. 
    18. Working Set이 주기억장치 내에 유지되어야 하므로 페이지 부재나 삭제가 이뤄진다 해도 다른 것으로 대체되서는 안된다.
    19. NUR(Not Used Recently) : 최근에 사용하지 않은 페이지를 교체하는 기법으로 각 페이지마다 2개의 하드웨어 비트(호출 비트, 변형 비트(dirty bit))가 사용된다.
    20. PFF 알고리즘은 프로세스의 상주 페이지 세트(resident page set)를 바꾼다. 
    21. 축소된 Working Set을 만나면 페이지 부재율이 높아져 Working Set을 많이 활용한다. 
    22. 128p의 34번 문제는 책을 참고할 것.
    
5. 프로세스 관리
    1. 프로세스 - 프로그램을 수행하는 처리기 그 자체, 수행 중인 프로그램을 의미
    2. 프로세스 제어블록에 포함되는 정보
        1. 프로세스 상태
        2. 포인터
        3. 레지스터 정보
        4. 기억장치 관리정보, 계정 정보 …
    3. 상위단계 스케줄링(작업 스케줄링) : 어떤 작업에 어떤 자원을 할당할 것인지 결정한 후 준비상태 큐로 보냄
    4. 중간단계 스케줄링: CPU를 할당받을 프로세스를 결정함, 중지, 활성화하며 부하 조절(특별한 경우에 있어 실행작업을 기억장치에서 제거하는 스케줄러)
    5. 하위단계 스케줄링 : CPU를 어느 프로세스에 배당할지를 결정하는 것으로 준비상태에 있는 프로세스들 중 CPU를 할당받을 특정 프로세스를 지정하는 작업. CPU를 프로세스에게 dipatch한다.
    6. 스케줄링 알고리즘
        1. 비선점형 알고리즘 - 우선순위 스케줄링, 기한부 스케줄링, FCFS, SJF, HRN
        2. 선점형 알고리즘 - RR, SRT 등
        3. RR : 도착 순으로 디스패치되지만 CPU에 제어하는 시간 할당량에 의해 제한을 받으며 대화식 사용자에게 적합한 선점형 스케줄링
        4. SRT : 다단계 피드백 큐의 마지막 단계에서 이용되는 스케줄링
        5. FSS : UNIX 환경에서 서로 관계있는 사용자들에게 한정된 비용으로 시스템 자원을 사용할 수 있도록 개발된 스케줄링
        6. 선점 스케줄링은 응답시간은 빠르나 경비가 많이 들고 오버헤드를 초래해 효과적인 선점을 위해서는 CPU 사용을 위해 대기중인 프로세스가 많아야 하고 우선순위를 깊이 고려해야 한다.
    7. 155p 19, 20번 문제는 책을 참고할 것.
        
        
6. 상호배제와 동기화
    1. 직접통신 링크 
        1. 링크는 양방향이다
        2. 각 통신 프로세스 쌍 사이에는 정확히 하나의 링크만 존재하므로 수 많은 프로세서와 관계할 수 없다
        3. 통신을 원하는 모든 프로세스의 쌍 사이에 링크가 자동으로 설정된다
    2. 다중 프로세싱 시스템 구성 방법
        1. 대칭 다중처리 구조, Master/Slave, 강결합/느슨한 결합
        2. (참고) Fork/Join 구조는 단일 프로세싱 시스템에서의 병행수행방법 중 하나다.
    3. 병행 프로세스
        1. 운영체제에 의해 이뤄지며 여러 개의 프로세스가 같은 프로세스를 공유한다.
        2. 상호간 제어 없이 동시에 실행 상태에 있는 2개 이상의 프로세스들을 말하며 같은 메모리, 입출력장치를 공유해 여러 병행성 문제가 발생할 수 있다.
        3. 프로세스의 병행성은 독립적 병행 프로세스와 협동적 병행 프로세스로 구분되는데 독립적 병행 프로세는 여러 프로세스들이 독립적으로 실행된는 것이며 협동적은 서로 협력하며 동시에 실행되는 것이다.
    4. 임계영역 : 하나의 프로세스가 수정이 가능한 자원을 가진 상태, 공유자원의 독점을 보장하는 영역
    5. 임계 영역의 문제를 해결하기 위한 조건 - 상호배제, 진행, 한계 대기
    6. P(s)에서 세마포어가 0이 되면 프로세스는 대기 상태가 되고 V(s)에서 세마포어를 증가시켜 1이 되면 대기 중이던 프로세스들 중 1개 프로세스만 진행된다. 
    7. 세마포어에 대한 연산은 처리 중에 인터럽트 되어서는 안된다. 
    8. 시간종속 오류 
        1. 프로세스들이 임의의 변수들을 공유하며 발생되는 것으로 어떤 특정 순서로 실행될 때에만 발생하고 항상 발생하는 것이 아니기 때문에 탐지하기 어렵다. 
        2. 시간종속 오류는 세마포어 사용 시 P(s)나 V(s) 또는 두 연산 모두를 수행하지 않은 경우 상호배제가 지켜지지 않거나 교착상태에 빠지게 되는 상황을 나타낸다. 
    9. 통신 링크 설정 시 고려사항은 링크들의 설정 방법과 링크의 용량, 메시지의 크기다.
        
        
7. 교착상태 
    1. 교착상태의 필수조건 4가지 - 상호배제, 점유와 대기조건, 비선점 또는 비중단, 환형대기
    2. 은행원 알고리즘
        1. 단점
            1. 할당할 수 있는 사용가능한 자원이 일정량 존재해야 한다
            2. 일정한 수의 사용자 프로세스가 있어야 적용이 가능하다
            3. 모든 프로세스는 유한한 시간 내에 할당된 자원을 반납해야 한다
            4. 사용자가 미리 최대 자원 필요량을 알고 있어야 한다
        2. 교착상태 가능성을 피해가는 방법으로 프로세스의 상태를 안전, 불안전 상태로 분류함
    3. 교착상태 탐지 알고리즘의 수행의 결정요소
        1. 교착상태 발생 빈도
        2. 프로세서의 처리율
        3. 교착상태에 영향을 받는 프로세스의 수
        4. 교착상태의 발생 시점
    4. 전용자원을 허용하고 있는 시스템에서 교착상태를 방지하기 위해 파기할 수 없는 조건은
        1. 상호배제 조건
        2. 상호배제를 제외한 나머지 3가지를 제거함으로서 수행된다.
    5. 프로세스가 자원을 이용하는 정상적인 작동순서
        1. 자원 요청 → 사용 → 해제
            
            
8. 장치 관리
    1. 시스템 장치는 일반적으로 3가지 범주에 속한다
        1. 전용장치(dedicated devices) : 한 번에 오직 하나의 장치만 할당하고 그것이 활성화될 때 전체시간을 할당한다. 대표적인 장치로는 순차접근에 사용되는 자기테이프가 있다.
        2. 공용장치(shared devices) : 여러 프로세스에 할당할 수 있는데 인터리빙 방식을 사용한다.
        3. 가상장치(virtual devices) : 스풀링 기법을 통해 전용장치에서 공용장치로 변환한다.
    2. 회전지연시간 : 디스크에 저장된 데이터가 디스크 헤드까지 회전하는데 소요되는 시간
    3. 탐색 시간 : 고정축을 새로운 실린더로 옮기는 과정으로 해당 데이터가 있는 트랙에 헤더가 위치하는데 걸리는 시간으로 디스크 액세스를 구성하는 시간 중 가장 많은 시간이 소요된다.
        1. 탐색 시간이 회전지연, 레코드 전송 시간보다 오래 걸린다.
    4. SSTF와 비슷한 방식으로 헤드가 지정된 트랙을 찾은 후 디스크가 회전하여 원하는 섹터에서 읽기/쓰기가 시작될 때까지 걸리는 회전시간의 최적화를 위해 구현된 기법 - SLTF(sector queuing)
    5. C-LOOK : 바깥쪽에서 안쪽 방향의 모든 요청을 처리한 후 바깥쪽 맨 끝으로 이동하는 것이 아니라 요청 트랙 중 가장 바깥쪽에 있는 트랙으로 이동한 후 안쪽 방향으로 요청을 서비스하는 기법으로 진행방향에서 앞을 보고 어떤 요구가 없을 경우 더 이상 진행하지 않는 스케줄링
    6. 기억장치 인터리빙
        1. 주기억장치의 액세스 속도를 빠르게 한다
        2. 각 뱅크마다 독립된 MBR, MAR를 구성해 여러 개의 뱅크에서 명령어 인출과 자료 인출을 동시에 수행하게 한다.
        3. 보통 뱅크스위칭 기법을 사용한다.
        4. 프로그램 재배치가 아닌 접근 시간을 줄이기 위해 사용한다.
    7. 자기테이프의 레코드 형식 중 고속의 처리속도와 프로그램 작성이 용이한 것 - 블록화 고정길이 레코드
    8. 229p 16번 문제는 책에서 직접 참고
    9. RAID 저장방식 3가지
        1. Striping 방식 - 분산 저장 방식으로 하나의 자료를 여러 디스크에 분산시키므로 입출력은 빠르나 장애시 복구가 어렵다.(RAID 0)
        2. Mirroring 방식 - 거울 저장 방식으로 같은 자료를 2개의 디스크에 동일하게 기록하므로 장애 시 복구가 용이하며 읽는 속도가 빠르다.(RAID 1)
        3. Parity 방식 - 스트라이핑 방식에 패리티 정보를 따라 기록 저장하므로 장애 시 패리티를 사용해 복구할 수 있으며 가장 많이 사용된다.(RAID 5)
            
            
9. 파일 관리
    1. 파일 단위 작업 : 개방, 폐쇄, 생성, 삭제, 복사, 이름 바꾸기, 목록 보기
    2. 레코드 작업 단위 : 읽기, 쓰기, 수정, 삽입, 삭제, 검색
    3. 마스터/사용자 파일 디렉터리라고 하며 트리 구조로 구현할 때 트리의 루트는 master file directory이고 아래 직계 자손은 user file directory이고 파일은 UFD의 자손인 디렉터리 구조는 2단계 구조 디렉터리다. 
    4. 블로킹 : 여러 개의 논리적인 레코드가 모여 하나의 물리적인 레코드를 구성한 파일
    5. 직접 파일 : 저장장치의 물리적 구조에 대한 구체적인 지식이 필요하다. 키 값에서 보조기억장치의 주소로 사상시키는 사상함수가 요구된다. 특정 레코드가 저장될 기억장치의 주소를 신속하게 계산해 줘야 한다.
    6. 자기테이프에 저장되는 파일은 순차파일이다.(직접 파일 아님)
    7. 디스크의 할당 기법 중 불연속 할당기법에 속하는 블록 체인 기법
        1. 디스크의 한 트랙 전체를 1개의 블록으로 정하는 방법으로 특정 레코드를 찾을 때 블록체인을 따라가서 해당 블록을 찾고 그 블록 내에서 다시 해당 레코드를 찾는다.
    8. 파일 시스템
        1. 불의의 사태에 대비해 백업, 복구 능력을 갖춰야 한다. 
        2. 그 외 파일을 공유하는 여러 종류의 접근 제어 방법 제공, 사용자가 파일을 생성, 수정, 제거할 수 있도록 해야함, … (하지만 컴파일러 기능이 필요하진 않음)
    9. 파일 시스템에서 파일에 저장된 정보를 손상되지 않도록 보장하는 기능 - 파일 무결성 보장
    10. 파일 디스크럽터
        1. 시스템에 따라 구조가 다르다
        2. 파일 제어블록이라고도 하며 시스템이 필요로 하는 정보를 갖고 있는 제어블록을 의미한다.
        3. 운영체제가 그 파일과 관련해 알아야 할 모든 내용들이 모두 기록되며 보조기억장치에 저장해 두었다가 파일이 개방될 때 주기억장치로 옮겨진다. 
        4. 파일 디스크립터는 운영체제가 관리하므로 운영체제에 의해서만 액세스할 수 있고 사용자는 참조할 수 없다. 
        5. 파일 디스크립터는 파일마다 독립적으로 존재하며 시스템에 따라 다른 구조를 가질 수 있다.
    11. 디렉터리 구조를 확장한 임의 트리로 하나의 루트 디렉터리와 다수 종속 디렉터리를 구성된 디렉터리를 트리 디렉터리 구조라고 한다.
    12. 1단계 디렉터리 구조 : 가장 간단한 구조로 장치 디렉터리 같은게 있다. 모든 파일이 동일한 디렉터리에 있어 유지하고 이해하기 쉽다. 파일 수가 증가하면 모두 고유한 이름이 필요하다.
    13. 비순환 그래프 디렉토리 구조 : 순환이 없는 구조로 하위 디렉터리가 상위 디렉터리나 상위 파일을 고유할 수 있고 하나의 파일이나 디렉터리가 경로 이름을 여러 개 가질 수 있다. 공유된 하나의 파일을 탐색할 경우 다른 경로로 두 번 이상 찾아갈 수 있어 성능 저하가 초래할 수 있다.
    
10. 유닉스 운영체제
    1. 셸
        1. UNIX의 핵심 부분으로 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행된다
        2. 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기로 시스템과 사용자 간의 인터페이스를 담당한다(커널과 일반 사용자를 연결시켜주는 명령어 해석기)
        3. 해석기 뿐만 아니라 프로그래밍 언어로도 사요ㅇ된다.
    2. 프로세스가 활성화된 경우에만 주기억장치에 상주하는 표 → 사용자 표
    3. 항상 메인 메모리에 상주하는 것 → 프로세스 표
    4. /dev : 장치 드라이버 파일들을 저장해 두는 디렉터리
    5. /usr : 사용자 관련 명령어들을 저장하는 디렉터리, 내부의 bin 디렉터리는 UNIX 시스템의 실행 파일을 저장한 디렉터리다
    6. /etc : 시스템 관리에 필요한 각종 설정 파일을 가짐
    7. /opt : 추가로 설치한 프로그램이 저장된 공간
    8. 리다이렉션 : 출력 방향, 입력 방향 둘 다 지시할 수 있다. 리다이렉션은 표준 입출력 스트림을 파일로 받는 것을 말한다. 입력 스트림의 경우 ‘<’을 사용하고 출력 스트림의 경우 ‘>’를 사용하는데 리다이렉션을 셀에 따라 다를 수 있다.
    9. UNIX에서 사용된 주기억장치와 보조기억장치의 교체 방법은 최초 적합(first-fit)이다.

1. 리눅스 운영체제
    1. 쉘 : 사용자와 운영체제의 내부(커널) 사이의 층으로 운영체제상에서 다양한 운영체제 기능과 서비스를 구현하는 인터페이스를 제공하는 프로그램
    2. - rwxr-x--x : 어떤 사용자라도 실행시킬 수 있음
        1. 소유자는 읽고 쓰고 실행할 수 있고, 그룹은 읽고 실행이 가능하고, 나머지 사용자들은 실행이 가능한 파일임을 뜻함(소유자 - 그룹 - 나머지 사용자 순서)
        2. r : 읽기 가능, w : 쓰기 가능, x : 실행 가능