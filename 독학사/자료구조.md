# 독학사 - 자료구조

1. 기본 개념
    1. 선형 자료구조 - 스택, deque, list, queue
    2. 비선형 자료구조 - tree, 그래프
    3. Zone 방식(Unpacked Decimal) : 10진수 1자리를 표기하는 방식 중 하나
        1. Zone 방식의 F6F8F2D1 → Packed 방식 DDDDDDS(D: 숫자, S: 부호)
        2. F6F8F2D1이 10진수가 -6821이므로 Packed로 나타내면 6821D가 된다.
    4. Packed 방식 : 10진수 1자리를 표기하는 방식 중 하나이나 4비트로 표현함, 10진수 1자리를 표현하는데 4비트를 이용하고 마지막 4비트는 부호를 표현하는데 사용하며 연산용이다.
    5. 46p 7번 문제 - 보수 표현
    6. EBCDiC 코드 C5(16)는 아스키 코드로 A부터 4번째인 E에 해당한다. A가 65니 E는 69고 2진수로 표현하면 100 0101
    7. big O 
        1. n! + 10n(3) = O(n!)
        2. 2(n) - 10n(5) = O(2(n))
        3. O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!)
            
            
2. 배열(여기는 그냥 책으로 보기)
    1. 연접 리스트 - 삽입 횟수 (n+1)/2, 삭제횟수 (n-1)/2
    2. 첫 번째 원소 위치가 100번지이고, 원소의 크기가 8바이트로 된 배열에서 A[11] 원소의 위치는 100 + 8 * 11 = 188 이다.
    3. 선형 리스트는 (순서 리스트는)
        1. 저장구조가 단순하고 기억공간에 연속으로 저장되 기억 효율이 좋다(1). 순차접근에 빠른 속도를 제공함.
        2. 삽입, 삭제, 갱신에 전체 복사가 필요해 속도가 느리고, 특정 자료에 접근할 때 처음부터 접근해야 해서 접근 시간이  O(n)이다. 노드 삽입이나 삭제나 노드의 이동 횟수가 많다.
        3. 순차구조로 연접리스트와 연결 리스트 구조로 나눈다.
    4. 연결 리스트는(linked list)
        1. 불연속적으로 저장된 구조로, 링크라는 포인트에 의해 노드들이 연결된다.
        2. 데이터 삽입/삭제가 쉽고 리스트의 분리, 결합이 쉽다.
        3. 링크를 따라 접근해야 해서 검색 속도가 느리고 링크를 위한 기억공간이 필요해 효율이 떨어짐.
        4. 알고리즘 구현이 복잡하다.
        5. 특정 노드 검색 시 무한 루프에 빠질 수 있다.
    5. 배열
        1. 원소의 참조는 지정된 순서로만 가능하다. 처음부터 순차접근 해야 한다.
        2. 추가와 삭제가 어렵다. 삽입, 삭제 시 전체를 이동해야 한다.
        3. 연속적인 저장공간이 필요하다.
        4. 기억 효율이 1(100%)로 좋다.
    6. 원래 행렬과 전치 행렬이 동일한 행렬을 대칭 행렬이라 한다.
    7. 배열의 위치(a(l, m, n) → a(k, i, j))
        1. 인덱스가 0일 경우 : k * (m * n) + (i * n) + j + 1
        2. 인덱스가 1일 경우 : (k-1) * (m*n) + (i - 1) * n + j
    8. 희소행렬을 리스트로 표기했을 때 첫 번째 원소는 [전체 행수, 전체 열수, 0이 아닌 원소 개수]이다.
    9. 7번 14번은 책에서
        
        
3. 연결 리스트
    1. 5번, 12번, 17번 책으로 확인(105p~)
    2. 환형 연결 리스트
        1. 헤드 노드를 가지므로 리스트의 시작을 알 수 있다.
        2. 양방향으로 순회 불가 - 양방향 순회가 가능한 건 이중 연결 리스트
        3. 마지막 노드가 링크의 처음 노드를 가리킨다.
        4. 단순 연결 리스트와 달리 임의의 노드에서 다른 노드로의 접근이 가능하다.
    3. 리스트의 이름이나 원소의 스트링 표현헤는 제한이 없다. 리스트 표현에는 head 포인터를 따로 지정하지 않는다. 일반 리스트일 때 head와 tail을 이용한다.
    4. 순차 리스트는 첫 데이터부터 순서대로 접근하면 되고, 연결 리스트는 head부터 link를 따라가며 접근해야 하므로 link를 통해 접근하는 시간이 순차 리스트보다 느리다.
    5. 데이터를 순환적으로 탐색할 수 있는 구조 - 환형 연결 리스트
    6. 환형 연결 리스트에서 헤드를 사용하는 이유는 임의의 노드 검색 시 무한 루프에 빠지지 않기 위함이다.
    7. 일반 리스트 구조는 tag - data - link
    8. 이중 연결 리스트나 단순 연결 리스트는 시작 노드로부터 특정 노드를 찾는 데 걸리는 시간이 동일하다.
    9. 희소 행렬을 연결 리스트로 구현할 때 가장 큰 장점은 기억 공간의 낭비가 적어 효율이 좋다는 점이다.
        
        
4. 스택과 큐
    1. 스택 
        1. 삽입 연산 - top = top + 1, 삭제 연산 - top - 1
        2. if top < = 0 then 노드 삽입해 top + 1 해서 공간 확보
        3. 주로 인터럽트 처리나 산술식 표현, 서브루틴 호출(호출된 프로그램에서 호출한 프로그램으로 되돌아올 주소를 기억시켜 놓기 위해 자주 쓰이는 것)에 스택을 사용
        4. 언더플로우가 발생하는 조건 : top < = 0
    2. 큐
        1. 선입선출 구조, 작업 스케줄링에 이용
        2. 환형 큐 : 선형 큐에서 queue-full 신호가 발생하면 큐에서 많은 데이터 이동이 일어나는데 이를 방지하기 위해 환형 큐를 사용한다.
            1. 환형 큐에서 언더 플로우가 발생하는 경우 : front = rear인 경우
                1. 초깃값이 front = 0임
            2. 환형 큐 외에 연결 리스트, 무빙 큐 등을 이용할 수 있다.
        3. 오버 플로우가 발생하는 경우 : rear ≥ n
            1. 큐에서 노드 삽입은 rear에서 일어나고 노드 삭제는 front에서 실행된다.
            2. front = rear = -1이 초기 조건이므로 rear의 값은 0부터 n-1까지 증가한다.
    3. 덱
        1. 출력 제한 덱 → shelf
        2. 입력 제한 덱 → scroll
        3. 스택과 큐의 복합 형태
        4. 사용하는 포인터는 2개
            
            
5. 트리
    1. 트리의 차수 : 모든 노드의 차수의 최댓값(depth), 각 노드가 가지고 있는 서브 트리의 수
    2. 루트 : 레벨이 제일 높은 1개의 노드
    3. 조상 노드 : 루트노드에서부터 임의 노드까지 경로를 형성하는 노드들
    4. 트리는 승자 및 패자 트리를 이용해 원소들 중 최댓값 또는 최솟값을 찾기에 유용하다
    5. 이진 탐색 트리는 원소 검색에 용이하다
    6. 컴파일 시 사용되는 파싱 트리는 컴퓨터 언어를 분석하는데 효율적으로 사용된다
    7. 이진 트리의 깊이가 k면서 전체 노드 수가 2^(k) - 1 인 이진 트리는 포화 이진 트리다. (각 레벨에서 노드가 가득 찬 경우다.)
    8. 이진 탐색 트리
        1. 서브 트리들도 모두 이진 탐색 트리로 구성된다.
        2. 모든 원소들이 키를 가지며 어떤 두 원소도 동일한 키를 가질 수 없다.
        3. 왼쪽 서브 트리의 키는 루트 키보다 작다.
        4. 오른쪽 서브 루트의 키는 루트 키보다 크다.
        5. 삽입되는 노드는 항상 단말 노드가 된다. 루트 키를 시작으로 작으면 왼쪽 자식 노드에, 크면 오른쪽 자식 노드에 삽입하며 탐색 트리를 확장한다.
        6. 노드 제거시 왼쪽 서브 트리가 존재하면 왼쪽 서브 트리의 가장 오른쪽 노드로 대치시키고, 중간 노드 제거 시 우측 서브 트리가 존재한다면 **우측 서브 트리의 가장 왼쪽 단말 노드**로 대치시킨다. 양쪽에 모두 노드가 있다면 둘 중 하나를 선택하는 후보자를 만든다. 
    9. 우선순위 큐를 구현하는데 사용되며 우선순위 큐에서는 우선순위가 가장 높은 원소를 삭제하는 구조는 힙트리다. 원소들 중 가장 큰 값 및 제일 작은 값을 검색하기 용이하다.
        1. max heap 
            1. 최대 힙을 말한다. 루트가 가장 큰 값으로 구성된 트리이므로 검색을 위해선 배열 표현법이 더 효율적이다. 
            2. 부모 노드 값이 자식 노드 값보다 작지 않은 트리다.
            3. 삭제 연산이 최악의 경우 O(logn)이다.
            4. 항상 완전 이진 트리다.
    10. 트리구조는 조직도, 산술 연산문, 가족 혈통 관계 표현하기 적합하다. 반면 행렬은 순차 구조라 배열이나 리스트로 표현하는게 적합하다.
    11. 이진 트리를 1차원 배열로 표현할 때
        1. 부노드에 대한 접근이 쉽다. 
        2. 포화 이진 트리에서는 기억 공간의 낭비가 없다.
        3. 사향 이진 트리에서는 기억 공간의 낭비가 많다.
        4. 노드의 삽입과 삭제 시 노드의 이동이 많다.
    12. 스레드 이진 트리 
        1. 스레드로 사용할 수 있는 링크 필드는 단말 노드의 경우 왼쪽, 오른쪽 링크 필드 모두 사용 가능하고, 중간 노드의 경우 오른쪽 노드 없이 왼쪽 노드만 있다면 오른쪽 링크 필드만 사용이 가능하다. 
        2. 스레드 이진 트리는 널 링크를 운행상 다음 노드를 지시하게 한다. 널링크의 개수는 일반 이진 트리의 노드가 n개일 때, n + 1이다. 
        3. 예를 들어, 노드의 개수가 6개라면 스레드 링크가 될 수 있는 널 링크의 개수는 7개다.
    13. 194p 3번 - 편향 트리, 전이진 트리, 정이진 트리, knuth 이진 트리
    14. 4번
    
6. 그래프
    1. 최소 비용 신장 트리 결정에서 현재 T에 포함된 간선들의 정점과 연결된 간선들 중에서 최소 비용 간선을 선택하는 방법 - Prim의 방법
    2. 사이클 : 처음과 끝의 정점이 같은 경로
    3. 정점의 수가 n인 무방향 그래프에서 최대 간선 수 = n(n - 1)/2
    4. 방향 그래프의 간선 수 = n(n-1)
    5. 그래프의 간선 항 나타내기
        1. 무방향 그래프 : E(G) = {(1, 2), (3, 2), (1, 3)}
        2. 방향 그래프 : E(G) = {<1, 2>, <3, 2>, <1, 3>}
    6. 한 정점에 부속된 간선의 수 → 차수
    7. 깊이 우선 탐색 : 정점 A에서 시작해 인접하면서 방문하지 않은 정점을 방문한다. 인접한 정점을 모두 방문했다면 이전 노드로 돌아가서 다시 깊이 우선 탐색 절차를 진행한다.
    8. 최소 비용 신장 트리 + Prim 알고리즘 : 인접 간선들 중 최소 비용을 갖는 간선을 선택해 연결해 가며 트리 형성
    9. 그래프를 인접 행렬로 표현했을 때,
        1. 행렬의 모든 요소는 0 아니면 1이다
        2. 무방향 그래프의 인접 행렬의 대각선 원소는 모두 0이다.
        3. 비방향성 그래프인 경우 대각선 원소를 기준으로 대칭 행렬이다.
        4. 무방향 그래프에서 i번째 행에서 값이 1인 요소의 수는 정점 Vi의 진출 차수와 같다.
    10. kruskal 알고리즘 - 간선의 가중치의 값이 가장 적은 값부터 사이클이 생성되지 않게 선택해가는 방식
        
        
7. 탐색과 정렬
    1. 버블 정렬 : 한 단계를 진행할 때마다 원소 중 가장 큰 값이 마지막에 놓임, n개면 n - 1번 정렬 단계
    2. 이진 탐색 : 먼저 정렬되어 있어야 함.
    3. 순차 탐색 : 가장 탐색 시간이 오래 걸림, (n + 1)/2, 정렬되지 않은 자료를 검색하는데 가장 효율적이다. 순차적으로 하나씩 비교하기 때문.
    4. 선택 정렬 : 처음부터 끝까지 최솟값을 찾아 그 값을 리스트의 첫 번째 값과 교환하는 기법
    5. 기수 정렬 : 여러 개의 키를 가진 레코드들을 분류할 때 가장 적합함
        1. n개의 10진수 원소를 기수 정렬할 때 준비해야 하는 큐의 길이는 10진법이므로 10 + 1가 필요하다.(n개)
    6. 삽입 정렬 : 1회전이 진행될 때마다 마지막 원소는 원소들 중 최댓값을 가지게 된다. 5개라면 1회전에 1, 2 번째 데이터를 비교해 정렬하고, 2회전에는 1, 2, 3번째 데이터를 비교해 정렬한다.
    7. 퀵 정렬 : 자료가 역순으로 되어 있으면 n개의 서브 파일로 분해되므로 연산 시간이 O(n^2)이 된다.
    8. 피보나치 탐색 : 나눗셈 대신 덧셈이나 뺄셈으로만 탐색이 가능해 기존값을 찾는 연산이 이진 탐색보다 빠르다.
    9. 정렬 알고리즘 선택 시 - 컴퓨터 시스템의 특성, 키값의 분포 상태, 키를 찾는 빈도수, 초기 자료의 배열 상태, 정렬할 자료의 양, 비교횟수와 자료 공간 등을 고려함(액세스 빈도는 고려하지 않음)
    10. 퀵 정렬, 2원 합병 정렬, 힙 정렬의 시간 복잡도는 O(nlogn)이고 선택정렬의 시간 복잡도는 O(n^2)이다.
        
        
8. 해싱
    1. 해싱 테이블의 오버플로 처리 기법 : 개방주소법(선형 방식, 제곱 방식), 폐쇄 주소법(체이닝 방식), 재해싱 기법
    2. 기수변환법 - key 값을 다른 진법으로 변환해 발생하는 값
    3. 해싱에서 충돌이 일어난 자리에서 그 다음 버킷들을 차례로 하나씩 검색해 최초로 나오는 빈 버컷에 해당 데이터를 저장하는 방법 - 선형 개방 주소법
    4. 해싱 탐색 - 키값으로부터 레코드가 저장되어 있는 주소를 직접 계산해, 산출된 주소로 바로 접근하는 방법으로 키-주소 변환 방법이라고 한다.
    

[https://jinhobak.tistory.com/215](https://jinhobak.tistory.com/215)