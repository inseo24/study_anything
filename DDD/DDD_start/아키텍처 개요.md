# 아키텍처 개요

### 4개의 영역

1. 표현
    
    사용자 요청을 해석해 응용 서비스에 전달
    
    응용 서비스의 결과를 사용자가 이해할 수 있는 형식으로 변환해 응답
    
2. 응용
    
    도메인 모델을 이용해 사용자에게 제공할 기능을 구현
    
    실제 도메인 로직 구현은 도메인 모델에 위임
    
3. 도메인
    
    도메인의 핵심 로직을 구현
    
4. 인프라스트럭처
    
    구현 기술에 대한 것을 다룸
    
    RDBMS 연동 처리, 메시징 큐에 메시지 전송하거나 수신 기능, 레디스 데이터 연동 등
    

### 계층 구조 아키텍처

계층 구조 특성상 상위 계층에서 하위 계층으로만 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.

짚고 넘어가야 할 점은 **표현, 응용, 도메인 계층이 인프라 계층에 종속된다는 점이다.**

도메인 가격 계산 규칙을 예로 들면,

할인 금액을 계산하기 위해 Drools라는 룰 엔진을 사용해 계산 로직을 수행하는 인프라 영역의 코드를 만든다고 생각해보자. 응용 영역에선 가격 계산을 위해 인프라 영역의 DroolsRuleEngine을 사용한다.

```kotlin
class CalculateDiscountService(
    private val ruleEngine: DroolsRuleEngine
) {

    fun calculateDiscount(orderLines: List<OrderLine>, customerId: String): Money {
        val customer = findCustomer(customerId)

				// Drools에 특화된 코드, 연산결과를 받기 위해 추가한 타입(mutableMoney)
        var money = mutableMoney(0)
        val facts = listOf(customer, money)
        facts.addAll(orderLines) // 얘네도 Drools를 안썼다면 필요하지 않을 수도 있는 리스트
        ruleEngine.evalute("discountCalculation", facts)
			// "discountCalculation" <- 얘도 Drools의 세션 이름
        return money.toImmutableMoney()
    }
}
```

위 코드는 동작은 하겠지만 2가지 문제가 있다.

1. CalculateDiscountService 만 테스트하기 어렵다. 
    1. 의존성으로 물고 있는 ruleEngine 도 확인해야 한다.
2. 구현 방식을 변경하기가 어렵다.
    1. Drools의 세션 이름을 변경하면 위의 코드 상 세션 이름도 변경해야 하고
    2. MutableMoney 또한 룰 적용 결과값을 보관하기 위해 추가한 타입으로 다른 방식을 사용했다면 필요하지 않을 타입이다.
    

겉으로는 인프라에 의존적이지 않은 것처럼 보이더라도 실제로는 인프라 기술에 완전히 의존하고 있다. 

인프라에 의존하게 되면 ‘테스트에 어려움', ‘기능 확장의 어려움'이라는 2가지 문제가 생긴다.

이 문제ㄹ는 다음 장의 DIP에 있다.

### DIP : 저수준 모듈이 고수준 모듈을 의존하게 하자

추상화를 이용해 의존 관계를 역전시키자!

고수준 모듈이 저수준 모듈에 의존하는게 일반적인데 이 경우 저수준 모듈이 고수준 모듈에 의존한다고 해서 이를 DIP라고한다. (의존 역전 원칙(

DIP를 이용해 다른 영역이 인프라 영역에 의존할 때 발생했던 두 가지 문제인 구현 교체 어려움, 테스트 어려움 문제를 해소할 수 있다.

→ 이를 위해 추상화한 인터페이스를 이용한다.

### 주의

DIP를 적용할 때 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출한다. 

Service 입장에서 할인 금액을 구하기 위한 특정 엔진을 사용한다는 것은 중요하지 않다. 규칙에 따라 할인 금액을 계산한다는 것이 중요할 뿐이다. 즉, 할인 금액 계산을 추상화한 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치한다.

### 도메인 영역의 주요 구성요소

- 엔티티
- 밸류
- 애그리거트
    - AGGREGAT
    - 하나로 묶은 군집
    - 주문 (상위) - 주문, 배송지 정보, 주문자, 주문 목록, 총 결제 금액(하위 개념) 으로 구성
    - 관련 객체를 묶어 객체 군집 단위로 모델을 바라볼 수 있음
    - 군집에 속한 객체를 관리하는 루트 엔티티를 갖음
- 리포지터리
    - 도메인 객체를 보관하는 도메인 모델
    - 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의함
    - 도메인 모델을 사용해야 하는 코드는 리포지터리를 통해 도메인 객체를 구한 뒤 도메인 객체의 기능을 실행한다. 도메인 모델 관점에서 repository는 도메인 객체를 영속화하는데 필요한 기능을 추상화한 것으로 고수준 모듈에 속한다. (→ 인프라에 속함)
- 도메인 서비스

### DB 테이블의 엔티티 vs 도메인 모델의 엔티티

두 개 사이의 가장 큰 차이점은 도에민 모델의 엔티티는 데이터와 함께 도메인 기능을 제공한다는 점이다.

도메인 모델의 엔티티는 단순히 데이터만 담는 데이터 구조라기보다 데이터와 함께 기능을 제공하는 객체이다. 

도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다.

또 다른 차이점은 도메인 모델의 엔티티는 2개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다는 점이다. 

RDBMS 같은 관계형 데이터베이스는 밸류 타입을 제대로 표현하기 어렵다.