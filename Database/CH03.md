- 정보공학에서 M:N의 규칙은 반드시 정보를 추적할 수 있도록 관계를 1:M 형식으로 해소해줘야 한다.
- 데이터 모델링은 논리 모델링과 물리 모델링을 구분하여 작업한다.

## M:N 관계 해소 방법

- 상호간의 관계가 1:M, M:1로 되는 경우를 M:N이라고 한다.

### 관계 엔티티타입 분리

- 예) 한 번에 여러 고지서의 납부를 할 수 있고, 하나의 고지서를 여러 번에 걸쳐 납부 할 수 있다.
    
    ![erd1.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/866c0d3e-6ac1-4efd-a2ae-262a7cad855a/erd1.jpg)
    
- 관계 해소 방법
    - 두 개의 엔티티타입과 관계가 있는 이름을 붙여 엔티티타입을 새로 생성(요금PK로 요금납부에서 모든 납부번호를 제대로 가져온다.)
        - 이름 붙이는 방법
            - 업무에서 사용하는 적절한 이름을 붙이거나 엔티티 발생 순서에 따라 두 엔티티타입 이름을 붙여서 만든다.

## Primary Key 통합(주식별자 통합)

- M:N 관계를 해소하면서 계속해서 분화되는 엔티티타입으로 인해 ERD가 복잡해지는 것을 막기위해 PK를 사용하여 하나의 엔티티로 통합 가능
- 예) 한 번에 여러 고지서의 납부를 할 수 있고, 하나의 고지서를 여러 번에 걸쳐 납부 할 수 있다.
    
    ![erd2.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e3df9eab-1530-46bc-9e93-2c4d3e0ee606/erd2.jpg)
    
- Primary Key를 통합하여 관계 해소
- 설명
    - 납부 엔티티타입에 요금번호(FK)가 존재 함으로 하나의 요금 고지서를 여러 번에 걸쳐 납부 가능(같은 요금번호를 FK로 가진 납부가 여러개)
    - 납부 엔티티타입에 Primary Key가 납부번호와 요금납부순차번호로 되어 있기 때문에 한번 납부할 때 여러 개의 요금에 대해 납부 가능(납부번호는 같고 순차번호를 다르게해서 PK 생성 하는듯)
    - 이 경우는 자식 엔티티타입이 반드시 부모엔티티타입과 생사를 같이 하는지 검증한 후에 진행한다.(요금이 없어지면 관련된 납부도 없어져야 문제가 발생하지 않는다. 얘는 왜 요금도 없는데 돈을 냈지? 같은 상황)
- 특징
    - 통합되는 엔티티타입의 속성이 많지 않고 데이터 수정이 많지 않으며 읽는 작업이 많이 발생하는 엔티티타입의 경우 적당(속성이 많을 경우 데이터 중복 발생)
    - 데이터 모델이 단순해 질 수 있으며, 여러 개의 테이블을 조인하지 않는다는 장점이 있음

## 부모 엔티티타입에 속성 추가

- 예) 하나의 요금고지서에 대해 최대 두 번까지는 분할 납부가 가능하다는 업무 규칙이 있다면 별도의 엔티티타입이 분리될 필요 없이 다음 그림처럼 표현 가능(납부번호2가 비어있으면 한번에 납부한 것이다)
    
    ![erd3.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b5551404-de8c-493e-9acc-2b4e851e831c/erd3.jpg)
    
- 특징
    - 해당 업무 규칙의 최대값이 적은 것이어야 하며, 최대값이 변경될 가능성이 적어야한다.(최대값이 많거나 변하면 M:N이랑 다를게 없어보임)
    - 이 방법을 적용하면 데이터 모델의 복잡도를 감소시키고 물리 테이블의 조인을 줄여주는 효과를 얻는다.
- 참고
    - 실선(Identifying): 식별관계
        - 부모테이블의 PK가 자식테이블의 FK/PK가 되는 경우
        - 부모가 있어야 자식이 생기는 경우
    - 점선(Non-Identifying): 비식별관계
        - 부모테이블의 PK가 자식테이블의 일반속성이 되는 경우
        - 부모가 없어도 자식이 생기는 경우

## 마무리

- 꼭 기억해야 할 사실은 관계 엔티티타입이 발견되는 시점에는 반드시 먼저 엔티티타입간 관계를 검증하여 관계 엔티티타입을 도출하도록 해야 한다.(엔티티타입이 발견됐는데 쓸데가 없으면 꽝이다)
- 이 작업이 완료되고 난 이후에 업무 발생 빈도 수, 업무 발생 최대값, 최대값의 변경 가능성 등을 조사하여 엔티티타입의 통합 여부를 결정해야 한다.(많이 발생하는데 통합하면 중복이 일어나니까)

## 1:1 관계 해소 방법

- 1:1 관계를 가진 데이터 모델 표현방법 네 가지
    1. 별개의 엔티티타입으로 따로 표현하는 방법
        
        ![erd4.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/791f4bce-5ca0-48f2-9e22-37eb57b2d69d/erd4.jpg)
        
        - 엔티티타입을 업무적 구분에 따라 개별 엔티티타입을 그대로 유지하는 방법
        - 전체 업무를 이해하는데 도움이 되고, 두 업무적으로 추가적인 사항이 발생하여 엔티티타입의 관계가 변경될 경우 유연하게 바꿀 수 있다. 즉 모델의 확장성이 좋다. 또한 각각의 엔티티타입과 관계를 가지는 다른 엔티티타입과의 업무 흐름이 명확해진다.(보기도 쉽고 변경도 쉽고)
        - 너무 많은 관계로 인하여 데이터 모델이 복잡해지고 데이터 모델을 물리 테이블로 구성할 경우 너무 많은 테이블을 읽어야 하므로 성능에 영향을 미칠 수 있다.(테이블이 너무 많아지면 JOIN을 많이 사용해야한다.)
        - 두 엔티티타입의 생성 시기가 명확하게 구분되고, 타 엔티티타입과의 관계가 서로 다르며 데이터를 선택할 때 개별 테이블에 있는 내용만 선택하는 경우가 많다면 개별 엔티티타입을 유지하는게 좋다.(다른데서 각자 할 일이 또 있으면 분리해 놓는게 좋다)
    2. 하나의 엔티티타입으로 완전히 통합하는 방법
        
        ![erd5.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5a2689f7-0706-454c-9555-bcbd552195a0/erd5.jpg)
        
        - 동일한 PK 구조를 가지는 것이 1:1 관계(한쪽 필수 관계)이므로 두 엔티티타입의 타 엔티티타입과의 관계가 비슷하고, 정보 활용이 같이 된다면 하나의 엔티티타입으로 통합한다.(청구와 출금의 PK가 같고 다른 곳에서 같이 쓰인다면)
        - 통합하는 기준
            - PK가 동일하게 사용될 수 있어야 한다.(하나의 PK로 구별이 가능해야 한다.)
            - 한 시점에서 두 엔티티타입이 동시에 발생되면 안 되고, 두 엔티티타입의 속성들이 비슷할 때는 하나로 통합하도록 한다. (청구에 따라 출금이 발생해야 한다. 각각 따로 요청이 들어와서 도잇에 발생하면 안된다.)
    3. 부분 통합을 하는 방법
        
        ![erd6.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09cc8452-0f79-4733-b33a-8eb91fd62ed9/erd6.jpg)
        
        - PK 구조는 동일하더라도 그 내용은 다른 경우가 있다.(청구와 출금에서 청구번호랑 출금 번호가 각각 업무에서 유용하게 사용되고, 청구번호에 따라 일자, 금액, 장소...등이 있고, 출금번호에 따라 일자, 금액, 장소...등이 별도의 의미를 갖고 있다면 따로 두거나 통합할때는 PK를 변경한다)(청구출금구분코드 = 청구인지 출금인지)
        - 이 경우 별도의 엔티티타입으로 유지하거나 하나의 엔티티타입으로 통합할 때는 PK를 변경하여 통합한다.
    4. 슈퍼 엔티티타입 생성
        
        ![erd7.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0ff4b45d-edb1-493f-8f25-427aeb5821ff/erd7.jpg)
        
        - 엔티티타입의 PK가 같고, 동일한 속성을 가지고 있으며, 일부 속성이 다르거나 각각의 관계가 다른 엔티티타입과 상이하게 발생할 때 생성

## 엔티티타입의 통합

### 엔티티타입 통합의 목적

- 업무 규칙에 의해 산출된 모든 엔티티타입을 그대로 유지하는 경우는 데이터 모델이 너무 복잡하고 너무 많은 테이블이 생겨 데이터베이스도 복잡해진다. 이로 인해 데이터를 가져오기 위해 여러 테이블을 조인하는 노력이 들기 때문에 통합하여 작업 수행한다.(복잡해서 정보 가져오기 힘드니까 통합)

### 엔티티타입 통합의 장점

1. 정보를 조회하는 작업이 용이해진다.
    - 조인이 여러번 발생하지 않는다.
2. 엔티티타입간 중복성이 제거된다.
    - 비슷한 속성이 통합되므로 단일화 가능
3. 동일한 규칙에 따라 하나의 엔티티타입으로만 표현 가능
    - 예) AS 서비스를 제공하는 업체에 접수를 방문 접수와 전화 접수로 나누어 존재할 수 있지만 동일한 업무 규칙을 가지므로 하나로 통합 가능
4. ERD 표현이 간편해진다.
    - 두개를 하나로 통합했으니까

### 엔티티타입 통합의 단점

1. 업무의 확장섬이 감소할 수 있다.
    - 유연하고 업무 변경에 영향을 덜 받는 모습은 모든 엔티티타입이 업무에 맞게 나눠졌을 때 볼 수 있다.(나눠져있으면 하나만 변경하면 되는데 통합되어 있으면 바꾸기 까다롭다.)
2. 데이터 모델만으로 업무 흐름을 이해하기 쉽지 않다.
    - 엔티티타입이 병합된 내용을 알고 있는 사람은 괜찮지만 그렇지 못한 사람은 이해하기 어렵다.(나눠져있으면 딱 보면 알수 있는데 통합되어 있으면 이게 왜 이렇지?)
3. 시스템 성능이 저하될 수 있다.
    - 많은 양의 데이터가 한군데 집약되어 있어서 데이터양 증가에 따른 성능 저하 가능
4. 속성에 제약을 걸지 못하는 경우 발생
    - 예) 정규 사원과 촉탁 사원의 경우 정규 사원은 소속부서가 반드시 필요하지만 촉탁 사원의 경우는 그렇지 않다고 하면 소속 부서 컬럼에 Not Null을 지정할 수 없다. Not Null, Check, Default Value 등을 지정하면 제약 사항이 발생할 수 있다.(나눠져 있으면 정규 사원의 소속 부서는 Not Null하고 촉탁 사원은 Null값을 포함할 수 있게하면 정규 사원의 경우는 소속 부서를 꼭 입력할 수 밖에 없다.)
5. 체크해야 할 조건이 늘어난다.
    - 서로 다른 성격의 엔티티타입이 한군데 있으므로 체크할 조건이 늘어난다.
    - 예) 정규사원에 관련된 프로세스는 WHERE 정규사원 = "Y" 조건이 포함되어야 하는 불편함
6. SQL 문장을 작성하기 힘들다.
    - 두 개의 엔티티타입이 각각 다른 PK를 가지면서 통합되었을 경우 두 엔티티를 동시에 하나의 로우로 표현하기 위해 조회해야 할 경우 SQL 문장은 작성하기 힘들거나 복잡해진다.

### 엔티티타입을 통합하는 순서

1. 엔티티타입과 PK 그리고 PK와 관련된 업무 규칙을 통합한다.
2. 관계와 관계에 의해 발생된 FK 그리고 FK와 관련된 업무 규칙을 통합한다.
3. 속성과 속성에 관련된 업무 규칙을 통합한다.

**엔티티타입 통합을 고려하는 경우**

1. PK가 동일한 엔티티타입이다.
    1. 완전 통합
        
        ![erd8.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5dd3a02f-e4fa-4ba7-abd1-cd03eef73fa5/erd8.jpg)
        
        - 일반적으로 동일한 키 구조를 가지고 있으면 대체적으로 동일한 엔티티타입으로 통합될 가능성이 많다.
            - 예)등록자주민등록번호를 PK로 갖는 엔티티타입과 접수자 주민등록번호를 PK로 갖는 엔티티타입
            - 예) 부동산 소유자와 부동산 전세자 엔티티타입이 따로 있는 경우 부동산관계자로 통합하고 관계자구분 속성을 추가한다.
                
                ![erd9.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e9160dc5-d360-4760-b4c0-803418361763/erd9.jpg)
                
        - 두 개의 엔티티타입이 통합될 때 추가적인 구분 속성을 고려하지 않고 하나로 통합되는 경우는 슈퍼타입과 서브타입의 형태로 나타낼 수 없지만, 추가적인 구분 속성이 필요한 경우는 슈퍼타입과 서브타입으로 구분하여 표현 가능
            
            ![erd10.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6c3c4405-c971-4ddd-bd24-7e588cbc320a/erd10.jpg)
            
2. 두 엔티티타입의 PK가 꼭 일치하지는 않지만, 엔티티타입의 성격이 비슷하여 둘 중 하나의 PK를 선택하여 통합하여도 나머지 PK는 AK(Alternate Key)로 이용될 수 있는 경우에 두 엔티티타입은 통합 대상이 된다.
    - 일반적으로 두 개 이상의 식별자 후보가 있는 경우 하나를 PK로 선택하고, 나머지는 AK로 하거나 아예 사용하지 않을 수도 있다.
3. 두 엔티티타입의 PK가 일치하지는 않지만 도메인이 비슷하고, 엔티티타입에 포함된 속성이 비슷할 경우 하나의 엔티티타입으로 통합할 수 있다.
    - 예) 작업 요청(PK:작업요청번호, 속성:작업요청내용, 작업요청일자, 작업 장소)
    - 작업완료(PK: 작업완료번호, 속성:작업완료내용, 작업완료일자, 작업장소, 작업담당자)
    - 작업관리(PK:작업번호, 속성:내용, 일자, 작업담당자, 관련작업번호(FK))로 통합하여 자기 참조 관계로 연결한다.
4. 복합 PK를 가진 엔티티타입에서 두 엔티티타입의 PK 구서잉 전혀 다르더라도 PK를 구성하는 복합 속성 중 일부 비슷한 속성을 이용하여 통합 엔티티타입을 구성할 수 있다.
    - 복합키로 구성된 엔티티타입의 경우 PK가 달라도 속성의 일부가 같으면 통합 대상이 될 수 있다.

## 코드 엔티티타입 설계 방법

### 코드화

- 정보화 시스템을 구현하는 대부분의 프로젝트에서는 일정한 규칙이 있는 업무의 데이터들을 코드화한다.
- 정보화 시스템을 구축할 때 어떤 업무의 데이터 단위를 일정한 체계로 구분하는 단위

### 데이터 모델링 방법

1. 한가지 코드 값이 반복적으로 나타나는 경우
    - 복잡한 데이터 모델
        
        ![erd11.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8e37b0ab-206b-47fb-8f1e-b1e9c849ee39/erd11.jpg)
        
    - 설계 순서
        1. 코드구분에 대해서 먼저 설계한다.
        2. 상세 코드와 코드값을 조사한다.
        3. 엔티티타입을 설계한다.
    - 변경된 데이터 모델
        
        ![erd12.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/31f687dd-6cfc-4e12-bc21-c85cb2317a13/erd12.jpg)
        
2. 한 가지 코드에 대해 여러 개의 속성이 반복되어 나타나는 경우
    - 한 가지 코드에 대해 여러 개의 속성이 반복적으로 나타나는 코드성 엔티티타입의 경우는 보통 일반적인 엔티티타입 설계와 마찬가지로 설계
        
        ![erd13.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/546f18b5-d450-4bb1-b2d9-107703ff6d74/erd13.jpg)
        

## 도미노 속성에 대한 데이터 모델링 방법

### 도미노 속성의 정의

- 앞의 값에 규칙적인 제약이 연쇄적으로 발생하는 경우를 도미노 속성이라 한다.
    - 책상에 의해 의자 크기 결정, 의자 크기에 의해 방석 크기 결정

### 도미노 속성의 데이터 모델링 방법

1. 해당 업무에서 도미노가 발생할 수 있는 최대값을 정의하여 모델링하는 방법
    
    ![erd14.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f5fc2b61-5b4a-438b-aedd-68168ec3f455/erd14.jpg)
    
    - 위 모델은 최대 제약이 4를 넘지 않는 경우에 적용
2. 도미노 속성을 BOM을 이용하여 모델링하는 방법
    - BOM = Bill Of Material, M:N의 속성을 자기 참조 관계를 풀어주는 데이터 모델링 방법
    - 부품의 특성이 M:N의 자기 참조 관계의 모습을 가진 것과 비슷하게 도미노 속성도 이와 같이 데이터 모델링한다.
    - 여러 개의 도미노 속성을 묶어 하나의 값처럼 사용하지 않고, 항상 상위 코드를 이용하여 하위 코드를 찾는 것처럼 연쇄적으로 이용할 때 사용하는 것이 좋다.
    - 단점은 SQL 문장을 작성할 때 "CONNECT BY", "START WITH" 등 일반적으로 사용하지 않는 SQL 문장을 사용한다는 것이다.
        
        
        ![erd16.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2fec89fd-6bb6-4410-ac7e-8631dfb698e4/erd16.jpg)
        

### 도미노 속성의 활용

1. 도미노 속성 전체를 하나의 속성처럼 활용하는 형태
    - 여러 개의 속성을 묶어서 하나의 단위로 사용하는 형태를 카탈로그(Catalog) 형태라고 하며, 속성을 이용한 모델을 적용했을 경우에 가능하며, BOM 모델을 적용하면 이 특징은 제공 불가
2. 사용자 인터페이스에서 앞 값에 의해 뒤의 값이 한정되어 보여주는 경우

## 메시지 엔티티타입 설계 방법

- 메시지는 사용자가 시스템을 조작하면서 받는 정보 시스템의 반응에 해당
- 애플리케이션에서 메시지를 처리하는 방법은 크게 세 가지 정도가 있다.
    1. 모든 개발 소스에 메시지를 코딩하여 개발하는 방법
    2. 헤더 파일이나 클라이언트 테스트 파일에 메시지를 정의하고 애플리케이션에서 임포트하여 사용하는 방법
    3. 데이터베이스에 저장하고 모든 개발자가 데이터베이스를 통해서 메시지의 내용을 가져와서 보여주는 방법

### 메시지의 종류

- 메시지의 종류는 정보(Information), 경고(Warning), 에러(Error) 세 가지로 구분된다.

### 메시지 데이터 모델링 과정

1. 업무와 관련하여 개발하고자 하는 시스템과 연관된 모든 메시지를 조사한다.
    - 개발 소스에서 사용하고자 하는 모든 메시지 유형을 에러, 경고, 정보, 시스템 에러, 조치 다섯 가지 유형으로 조사한다.
2. 메시지 성격에 맞게 데이터 모델링을 진행한다.

### 방법

1. 하나의 엔티티타입으로 설계
    
    ![erd17.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/47db2794-bab6-437b-89a3-c804202562eb/erd17.jpg)
    
2. 응답을 분리하여 설계
    
    ![erd18.JPG](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/35702947-451b-46c5-baee-56a233075d5b/erd18.jpg)
    

## 이력 엔티티타입 설계 방법

- 하나의 업무 단위가 시간이 흐름에 따라 발생하는 과거와 현재 데이터를 지속적으로 유지하는 관리 방법을 이력 관리라 한다.
- 이력 관리를 위해 데이터 모델에 반영하여 표현한 엔티티타입을 이력 엔티티타입이라 한다.
- 정보화 시스템을 구축하는 해당 업무에서 가장 중요한 업무에 많이 적용
    - 예) 과거 데이터를 추적하거나 통계 데이터 활용 등 데이터 분석을 많이 하는 엔티티타입에 적용

### 이력 데이터 발생의 세 가지 유형

1. 변경 이력
    - 이미 관리하는 데이터에 대해 변경이 발생한 경우에도 업무상 필요에 의해 신구 데이터를 모두 관리하는 것
2. 발생 이력
    - 시간에 따라서 발생하는 데이터를 모두 관리하는 것
3. 진행 이력
    - 업무가 진행되는 상태를 모두 관리하는 것

### 이력 데이터의 데이터 모델링 방법

- 가장 중요하게 고려해야 할 부분은 엔티티타입에 대한 식별 및 구성과 그 엔티티타입이 가지는 관계 그리고 PK다
- 엔티티타입은 변경 이력, 발생 이력, 진행 이력에 따라 세 가지로 구분하여 식별한다. 세 가지 모두 꼭 업무에 필요한지 통계 정보나 기업 의사 결정에 필요한 정보인지 먼저 검토하고 필요한 업무에 대해서만 데이터 모델에 반영한다.

1. 엔티티타입의 구성을 결정한다.
2. 이력이 발생한다는 것은 동일한 엔티티타입에 대해 시간에 따라 데이터가 발생하는 것이므로 시간을 나타내는 속성이 필요하다.
3. 이 때 엔티티타입을 한개로 유지할 것인지 두개로 분리할 것인지 결정
4. 시간에 따라 일부의 속성만 변하는지 전체가 변하는지 파악후 일부만 변할 경우 두 개의 엔티티타입으로 분리하여 설계
5. 모든 속성이 시간에 따라 변한다해도 데이터를 조회하는 유형에 따라 분리 여부 결정
6. 업무에서는 항상 현재 유지되는 정보만 조회하고 과거 데이터는 가끔 조회한다면 엔티티타입을 현재와 이력으로 분리하여 설계 가능
- 진행 이력은 대부분 어떤 상태가 시작되고 종료되는 특징이 있다. SQL문장의 간결함을 위해 종료일자를 반드시 속성에 포함시키자.