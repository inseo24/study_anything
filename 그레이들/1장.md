# 1장 그레이들의 세계

## 1.1 그레이들이란

그레이들은 빌드 툴로 간단하게 빌드 스크립트를 작성할 수 있다는 특징을 갖는다.

또한, 스크립트가 간단해서 배우기 쉽고 읽기도 쉬워 처리 내용을 금방 이해할 수 있다. 

또 다른 특징으로 앤트나 메이븐 같은 기존 빌드 툴의 기능과 시스템을 활용할 수 있다.(메이븐 저장소 이용 가능)

빌드 툴의 발전 과정에 대해서 설명해보겠다.

### 1.1.1 빌드 툴이란

소프트웨어 개발에서 대부분의 작업은 정형화되어 있다. 자바 애플리케이션 개발에선 예를 들어, 다음과 같은 일련의 작업이 필요하다.

- 소스 코드(.java)를 컴파일해서 클래스 파일(.class)을 생성한다.
- 코딩 규약에 맞게 작성했는지 확인한다.
- 코드를 정적으로 해석한다.
- 테스트를 하고 테스트 결과나 커버리지 측정 결과를 리포트로 출력한다.
- Javadoc과 같은 문서를 작성한다.
- 클래스 파일과 리소스 파일을 패키징해서 압축 파일을 만든다.(.jar나 .war 파일)
- 압축 파일을 테스트 환경이나 스테이징 환경에 배포한다.
- 압축 파일을 저장소에 등록한다.

Ruby 같은 스크립트 언어는 컴파일이 필요하지 않지만, 테스트 실행, 패키징, 배포와 같은 정형화된 작업은 필요하다.

빌드 툴은 이런 정형화된 작업을 자동화하기 위한 소프트웨어다. 빌드 툴의 필요성을 좀 더 이해하기 위해 빌드 툴을 사용하지 않았을 때 부딪힐 수 있는 문제를 생각해보자. 

- 코드를 수정해서 테스트할 때마다 수작업으로 컴파일→테스트→패키징→배포 작업을 한다. 수작업이라 실수를 종종 한다.
- 개발 팀에 팀원이 추가되어 개발 중인 애플리케이션을 만져보게 했다. 하지만 작업 매뉴얼이 오래되어 코드 저장소에서 체크아웃한 후의 처리가 제대로 동작하지 않는다.
- 개발자의 로컬 장비에서 빌드가 되는데 테스트 환경에서는 빌드에 실패한다. 운영체제나 개발 환경이 달라서인 듯한데 자세한 원인은 모르겠다.
- 프로젝트 빌드에 필요한 오픈 소스 라이브러리를 일일이 내려받기가 쉽지 않다. 게다가 해당 라이브러리와 다른 라이브러리 사이의 의존관계를 고려해야 하므로 필요한 환경을 갖추기까지 컴파일을 몇 번씩 하면서 시행착오를 거쳐야 한다.
- 개발한 라이브러리를 오픈 소스로 공개했지만, 코드를 바이너리로 만들기가 어려워 사용자가 거의 없다.

이런 문제들을 빌드 툴을 적용해서 어느 정도 해결할 수 있다. 일반적인 빌드 툴에서는 빌드 순서를 빌드 스크립트로 작성해 실행하면 다양한 작업을 자동화할 수 있다. 이는 빌드 매뉴얼이 문서에서 실행 가능한 프로그램 형태로 바뀐다는 것을 의미한다.

빌드 매뉴얼이 실행 가능한 형태가 되면 다음과 같은 장점이 있다.

- 정형화된 작업에 사람이 관여하지 않아도 되니 실수가 줄어든다.
- 빌드 스크립트는 항상 관리되므로 문서처럼 낡은 정보가 될 위험이 줄어든다.
- 조건 분기를 이용해 각 환경에 따른 처리를 할 수 있다.(어디까지 가능하지는 빌드 툴의 기능에 달려있다.)

### 1.1.2 빌드 툴의 역사

스트럿츠(Struts)나 스프링 같은 프레임워크에 비하면 존재감이 약하나 빌드 툴은 착실히 발전해왔다.

간단히 진화 흐름을 살펴보자.

**Make**

- 원조 빌드 툴로 유닉스 계열 운영체제에서 사용됐다.
- Makefile이라는 통합된 구조로 작업을 처리한다.
- 처음으로 빌드 개념을 가져온 게 Make다.

**Ant**

- 자바를 위한 빌드 툴
- XML(eXtensible Markup Language) 기술 도입
- 간단하고 사용하기 쉽지만, 약간만 복잡한 처리를 하려고 하면 빌드 스크립트가 장황해지는 단점이 있다.
- 라이브러리 의존관계를 관리하는 구조가 없어 빌드 달인이 항상 고생했어야 했다.

**Maven**

- 빌드 툴 계의 혁명 메이븐은 앤트의 단점이었던 장황한 빌드 스크립트 문제를 해결했다.
- 빌드 생명 주기(lifecycle), 프로젝트 객체 모델(POM)이라는 새로운  개념을 도입
- POM에 메타 데이터를 적용해 라이브러리 의존관계를 자동으로 관리해주는 기능을 구현했다. 이는 의존 라이브러리 관리를 위해 Maven Central Repository를 제공했기에 가능했다.
- 다만, 기능이 많다 보니 이해해야 할 암묵적인 규칙도 많고, 만약 기본 규칙을 벗어난 처리를 하려면 갑자기 사용이 어려워진다는 단점도 있다.

**Gradle**

|  | 처리 기반 | 규칙 기반 |
| --- | --- | --- |
| 스크립트 | 메이크 | 그레이들 |
| XML | 앤트 | 메이븐 |
- 2가지 기준을 갖고 설명한다.
    - 빌드 스크립트 작성이 정적(XML) 방식인지, 아니면 동적(Script) 방식인지
    - 빌드 스크립트 작성이 처리 기반인지 규칙 기반인지
    
- 큰 흐름만 보면 2가지 진화 과정을 볼 수 있다.
    - 메이크: 빌드 개념 확립
    - 앤트: 범용성을 높임(=크로스 플랫폼 대응)
    - 메이븐: 빌드 스크립트 작성 효율을 높임(=규칙 기반)
    - 그레이들: 유연성을 높임(=스크립트 언어로 회귀)
    
- 한 마디로 그레이들은 “**스크립트 언어를 이용한 규칙 기반 빌드 툴**”이다.
    - 그레이들은 이 진화를 실현하기 위해 크로스 플랫폼 스크립트 언어(JVM 언어)인 그루비를 기반 기술로 선택했다.
    - 그루비의 기능 중 빌드 영역에 적합한 것이 많아서 현재까지는 이 선택이 성공적이었다고 평가받고 있다.

### 1.1.3 그레이들 개요

그레이들을 “Build Automation Evolved”, 즉 “진화된 빌드 자동화"라고 소개한다.

이 진화에는 2가지 의미가 있다.

- 그레이들은 빌드 자동화뿐만 아니라 테스트 실행, 결과물 공개, 각종 소프트웨어 개발 테스크 자동화, 정적 웹 사이트 생성, 문서 생성과 같은 소프트웨어 개발 이외의 프로젝트 자동화에도 적용할 수 있다.
- 그레이들은 앤트의 유연성, 메이븐의 의존관계 관리와 규칙 기반 등 기존 빌드 툴의 장점을 갖고 있고, 그루비 DSL을 도입해서 효율적인 빌드를 실현했다.

**DSL(Domain-Specific Language)은 도메인 특화 언어로, 특정 영역이나 프로그램에 특화된 독자적인 언어를 가리킨다. C나 자바 같은 범용적인 언어와 상반되는 개념이다.

그레이들의 주요 특징은 다음과 같다.

- 확장 가능한 그레이들 빌드 언어(DSL) 제공
- 빌드 분할이나 공통 컴포넌트 추출 등 체계화하기 쉬움
- IDE와 연계해서 그레이들을 외부에서 제어할 수 있는 API 제공
- 변경 내역 빌드나 병렬 빌드와 같은 빌드 효율화
- 멀티 프로젝트를 지원하는 유연성
- 메이븐/아이비 저장소부터 로컬 파일 시스템까지 다양한 의존관계 관리 기법 대응
- 앤트 태스크뿐만 아니라 앤트 프로젝트 전체와 통합 가능
- 빌드 스크립트 작성 언어로 그루비 이용
- 그레이들 래퍼(wrapper)를 이용해서 그레이들이 설치되지 않은 환경에서도 빌드 가능
- 호환성 배려

## 1.2 왜 그레이들이어야 하나

### 1.2.1 빌드 스크립트 생산성이 높다

규칙 기반 빌드 접근법으로 규칙에 따라 프로젝트 구조(디렉토리 구조)를 만들면 빌드 스크립트 내용을 크게 줄일 수 있다. 또한, 규칙을 벗어난다 해도 필요에 따라 스크립트를 추가할 수 있어서 유연하게 대응할 수 있다.

그루비를 사용해 자바 엔지니어라면 쉽게 익힐 수 있고 그루비에서는 리스트 리터럴, 맵 리터럴, 클로저 등 자바에 없는 편리한 기능이 있어 빌드 스크립트를 간단하게 작성할 수 있게 해준다.

동적 타이핑을 이용해 구현된 DSL을 이용할 수 있어, 빌드 스크립트를 간략하게 해준다.

앤트나 메이븐은 이런 빌드 언어 대신 XML을 사용하는데, XML에는 이런 언어 처리 기능이 없다. 따라서 조건 분기나 반복 기능을 구현하려면 앤트나 메이븐에서 구조를 바꿔서 직접 해당 기능을 만들어야 한다. 

반면 그레이들은 DSL은 그루비로 구축되어 있어서 그루비가 제공하는 언어 기능을 그대로 이용할 수 있다. 게다가 그루비는 자바 클래스를 직접 호출할 수 있으므로 빌드 스크립트에서 자바 유틸리티도 쉽게 사용할 수 있다.

그루비는 JVM만 있으면 동작하므로 특정 플랫폼에 의존하지 않는 빌드 스크립트를 작성할 수 있다. 즉 크로스 플랫폼 대응이 가능해진 것이다. 예를 들어, 개발 환경은 윈도우와 맥이고, CI 서버는 리눅스를 사용하는 환경을 구축할 수도 있다.

### 1.2.2 빌드 순서를 제어하기 쉽다

메이븐에서는 POM(Project Object Model)을 도입해 표준 빌드 순서(빌드 lifecycle)를 만들고, 메타 데이터를 이용해 의존관계를 해결했다.

하지만 메이븐의 빌드 순서는 추가나 변경이 불가능해서 메이븐의 빌드 순서에 맞지 않는 프로젝트에는 적용할 수가 없다. 빌드 스크립트 단순화 전략에 따라 불필요한 기능을 제거했기 때문이다.

그레이들은 메이븐처럼 빌드 순서가 정해져 있지 않다. 그레이들 빌드 순서는 태스크(빌드 순서의 각 단계) 의존관계에 따라 정해진다.

그레이들의 처음 상태에서는 태스크 의존관계가 정의되어 있지 않다. 사용자가 빌드 스크립트에 태스크 의존관계를 정의하면 이에 따라 빌드 순서가 정해진다. 하지만 이것만으로 앤트의 문제였던 빌드 스크립트의 복잡성을 해결할 수는 없다. 대신 플러그인을 사용해서 태스크 의존 관계의 기본 구성을 할 수 있다. 이 의존관계는 어디까찌나 기본 구성이므로 얼마든지 빌드 순서를 재정의해서 바꿀 수 있다.

### 1.2.3 멀티 프로젝트에 대응한다

아래 기능을 통해 서브 프로젝트로 구성된 전체 프로젝트 빌드를 지원한다.

- 멀티 프로젝트에 있는 서브 프로젝트를 정의하는 기능
- 서브 프로젝트에 공통 빌드 스크립트를 집약하는 기능
- 서브 프로젝트 간 의존관계를 정의하는 기능
- 의존관계를 고려해서 변경 내역만 빌드하는 기능

### 1.2.4 컴포넌트로 만들기 쉽다

빌드 스크립트도 프로그램의 일종으로 ‘공통 기능을 컴포넌트로 만들어서 재사용하고 싶다'는 요구가 있을 수 있다. 그레이들은 쉽게 사용할 수 있는 것부터 컴포넌트로 제대로 만들어서 공개 저장소에 등록할 수준의 것까지 유연하게 대응할 수 있는 컴포넌트 구조를 제공한다. 

- 빌드 스크립트에서 메서드나 클래스 추출
- 빌드 스크립트의 분할과 재사용(apply from 이용)
- 프로젝트에서만 사용할 수 있는 확장 모듈(buildSrc 프로젝트)
- 여러 프로젝트에서 범용적으로 재사용할 수 있는 라이브러리

그레이들의 장점은 컴포넌트화 수준을 단계적으로 향상화할 수 있다는 점이다.

### 1.2.5 별도로 설치할 필요가 없다

그레이들은 wrapper를 제공해 프로젝트 안에 그레이들의 bootrstrap을 심어서 지정한 버전의 그레이들을 자동 설치해준다. 단지 그레이들의 래퍼 태스크를 실행해서 부트스트랩을 생성하기만 하면 된다.

그걸 그대로 버전 관리 시스템에 등록하면, 사용자는 버전 관리 시스템에서 프로젝트를 checkout만 하면 된다.

체크아웃 후 gradlew 명령을 실행하면 그래이들의 바이너리가 다운로드되면서 빌드가 실행된다.

또한 그래이들 래퍼는 젠킨스 같은 CI 서버에서 빌드할 때도 편리하게 사용할 수 있다. CI 서버에 자바가 있다면 버전 관리 시스템에서 파일을 체크아웃해서 gradlew 명령을 실행하면 된다. 별도의 빌드 툴을 도입할 필요가 없다. 특히, 분산 빌드처럼 불특정 다수의 장비에서 빌드할 때 매우 유용하다.

### 1.2.6 호환성을 최대한 배려한다

그래이들에는 다음과 같은 방침이 있다.

- 기존 기능을 갑자기 사용할 수 없게 되는 변경은 하지 않는다.
- 기능을 제거해야 한다면 장래에 폐지될 가능성이 있음을 명시하고 단계적으로 제거한다.
- 신기능은 피드백을 충분히 받아서 안정화한 후에 추가한다.

## 1.3 다른 빌드 툴과의 비교

생략(위에만 읽어도 왜 그래이들을 사용하는지 알 거 같다)