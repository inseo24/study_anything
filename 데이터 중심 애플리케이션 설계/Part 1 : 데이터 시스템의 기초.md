## Part 1 : 데이터 시스템의 기초

### 01. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

- 데이터 중심 애플리케이션의 standard building block
    - database, cache, search index, stream processing, batch processing
- 작업을 **수행할 수 있는** task 단위로 나눔
- composite data system : 데이터 처리, 저장을 위해 사용되는 여러 도구들
    - 대부분의 소프트웨어 시스템에서 중요하게 여기는 3가지 관심사 : 신뢰성, 확장성, 유지보수성
    

### 신뢰성

- tolearating hardware & software faults, Human error
- fault를 예측하고 대처할 수 있는 내결함성(fault-tolerant, 특정 유형에 대한 결함 내성(모든 유형 x)) 또는 탄력성(resilient) 있는 시스템을 설계해야 함
- fault(결함) ≠ failure(장애)
    - 결함은 사양에서 벗어난 시스템의 한 구성 요소, 장애는 시스템 전체가 멈춘 경우
- 대부분의 결함은 미흡한 오류 처리에 기인함 → 넷플릭스 Chaos Monkey(고의적 결함 유도 테스트)
- 보통은 해결책이 중요하지만 보안처럼 예방책이 중요한 경우도 있음
- 결함
    - 하드웨어
        - MTTF(mean time to failure, 평균장애시간)이 약 10~50년으로 10,000개의 디스크로 구성된 저장 클러스터는 평균적으로 하루에 한 개의 디스크가 죽는다고 예상.
        - 장애율을 줄이기 위한 방법
            - 중복(redundancy)을 만듦
                - 디스크는 RAID 구성으로 설치, 서버는 이중 전원 디바이스와 hot-swap이 가능한 CPU를, 데이터센터는 건전지와 예비 전원용 디젤 발전기를 갖추기 등
                - 이런 다중 장비 중복은 과거 고가용성(high availability)이 절대적으로 필수적인 곳에서만 필요했지만 현재는 요구사항도 많아지고, AWS와 같은 클라우드 플랫폼을 사용하면서 유연성(flexibility)과 탄력성(elesticity)을 우선적으로 설계됌(하드웨어 결함율도 증가)
                - 현재는 소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 점점 옮겨감(전체 시스템의 중단 없이 한 번에 한 노드씩 패치하기 등(순회식 업그레이드(4장) 등))
    - 소프트웨어
        - 시스템 내 체계적 오류(systematic error) : 예상하기 어렵고 하드웨어보다 더 시스템 오류를 많이 유발함
            - 잘못된 특정 입력(윤초), 공유 자원 과도하게 사용하는 일부 프로세스, 잘못된 응답 반환하는 서비스, 연쇄 장애(cascading failure)
        - 신속한 해결책이 없음
            - 시스템의 가정, 상호작용에 대해 깊게 생각하기, 빈틈 없는 테스트, 프로세스 격리, 죽은 프로세스의 재시작 서용, 시스템 동작 측정, 모니터링, 분석 …
    - 인적 오류 해결 방안
        - 오류의 가능성을 최소화하는 방향으로 시스템을 설계할 것
        - 비 프로덕션 샌드박스를 제공하라
        - 모든 수준에서 철저히 테스트하기(자동 테스트는 코너 케이스까지 다뤄줘서 유용함)
        - 쉽게 복구할 수 있게 하기(롤백, 롤아웃)
        - 성능 지표와 오류율 같은 모니터링 대책 마련하기(원격 측정(telemetry), 지표(metric) 분석)
        - 조작 교육과 실습을 시행 - 온보딩 같은 개념? good management, training

### 확장성

- Measuring load & performance, Latency percentiles, throughput
- 시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가? 추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?

- 부하 기술하기
    - 시스템의 현재 부하를 간결하게 기술해야 부하에 관련해 논의할 수 있다.
    - 부하 매개변수(load parameter) : 선택은 시스템에 따라 달라짐
        - 웹 서버의 초당 요청수
        - 데이터베이스의 읽기 대 쓰기 비율
        - 대화방의 동시 활성 사용자(active user)
        - 캐시 적중률
    - 트위터 예시
        - 트위터의 초당 12,000건의 쓰기 처리는 쉬우나, 확장성 문제는 주로 fan-out에 있다.
            - fan-out : 트랜잭션 처리 시스템에서 하나의 수신 요청을 처리하는 데 필요한 다른 서비스 요청 수를 설명
            - 개별 사용자가 많은 사람을 팔로우하고, 많은 사람이 개별 사용자를 팔로우한다.
                - 구현 방식 1 : 작성된 새로운 트윗을 트윗 전역 컬렉션에 삽입하고, 사용자는 자신의 홈 타임라인 요청 시 팔로우하는 모든 사람을 찾고, 그 사람들의 모든 트윗을 시간순으로 정렬해 합친다.
                - 구현 방식 2 : 각 수신 사용자용 트윗 우편함처럼 개별 사용자의 홈 타임라인 캐시를 유지한다. 사용자가 트윗을 작성하면 해당 사용자를 팔로우하는 사람을 모두 찾아 팔로워 가갖의 홈 타임라인 캐시에 새로운 트윗을 삽입함(홈 타임라인의 읽기 요청은 요청 결과를 미리 계산했기 때문에 비용이 저렴함)
            - 1번 방식은 질의 부하 버티기 힘들어서, 2번 방식으로 전환함.
            - 보통 새로운 트윗을 올리는 것보다 읽기 요청량이 수백 배 많아서 2번 방식이 더 잘 동작함
            - 2번 방식은 쓰기에 있어 더 많은 부가 작업이 필요함. 단, 팔로워 수에 따라 달라짐.
            - 트위터 예시는 사용자당 팔로워 분포가 팬아웃 부하를 결정해서 확장성 논의 시 핵심 부하 매개변수가 된다.
            - 결론은 hybrid로 팔로워 수가 매우 많은 소수 사용자는 팬 아웃에서 제외시킴(이 경우 1번 방식으로 처리)

- 성능 기술하기
    - 부하 매개변수를 증가시키고 시스템 자원은 변경하지 않고 유지하면 시스템 성능은 어떤 영향을 받을까?
    - 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?
    - 부하 매개변수
        - 처리량(throughtput, 초당 처리할 수 있는 레코드수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간)
        - 응답시간(response time, 클라이언트가 요청을 보내고 응답을 받는 사이의 시간, 네트워크나 큐 지연도 포함함) - 단일 숫자가 아닌 측정 가능한 값의 **분포**로 생각해야 함
        - 지연 시간(latency, 요청이 처리되길 기다리는 시간, 서비스를 기다리며 latent 상태임)
        - 평균 응답 시간
        - 보통은 백분위(percentile)를 사용하는 편이 더 좋음
        - 중앙값(median) : 사용자가 보통 얼마나 오랫동안 기다려야 하는지 알고 싶을 때 사용
        - 특이값(outlier)
        - 상위 백분위 : 특이 값이 얼마나 좋지 않은지 알고 싶다면 살펴보는 걸 추천. 보통 95분위, 99분위, 99.9분위가 일반적(p95, p99, p999)
        - 꼬리 지연 시간(tail latency)
            - 아마존은 응답 시간이 100밀리초 증가하면 판매량이 1% 줄어들고, 1초가 느려지만 고객 만족도 지표가 16% 줄어드는 현상을 관찰함
        - 서비스 수준 목표(service level objective, SLO)
        - 서비스 수준 협약서(service level agreement, SLA)
        - 큐 대기 지연(queueing delay), head-of-line blocking
- 부하 대응 접근방식
    - 부하 매개변수가 어느 정도 증가하더라도 좋은 성능을 유지하려면 어떻게 해아 할까?
    - 용량 확장(scaling up, 수직 확장(vertical sacling))
    - 규모 확장(scaling out, 수평 확장(horizontal scaling))
    - 탄력적인 시스템은 부하를 예측할 수 없을 만큼 높은 경우 유용하지만 수동으로 확장하는 시스템이 더 간단하고 운영상 예상치 못한 일이 더 적다.
    - 범용적이고 모든 상황에 맞는 확장 아키텍처는 없다. 읽기의 양, 쓰기의 양, 저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴 등으로 아키텍처는 정해진다.

### 유지보수성

- Operability & simplicity, evolvability
- 운용성 : 운영팀이 시스템을 잘 운영하게 쉽게 만들기, 자동화
- 단순성 : 이해하기 쉽게 만들기, 우발적 복잡도를 줄이기 위해 추상화 활용
- 발전성 : 유연성, 수정 가능성, 적응성. 이후에 쉽게 변경할 수 있게 만들기, 애자일, 리팩토링