# 디지털 컴퓨터와 2진법 알기

1. 디지털과 논리 연산
    1. 아날로그 시스템
        1. 끊이지 않는 연속성 데이터
        2. 소리, 빛, 무게 등 자연계의 모든 신호
        3. 아날로그는 노이즈에 취약해 아날로그로 저장 후 사용할수록 손실 발생
        4. 가장 정확한 참 값
        5. 압축이 불가능
        6. 훼손된 정보는 원래 데이터의 복원이 불가능
        7. 연속적인 정보를 입력 받아 처리해 연속적인 정보를 그래프 형태로 출력하는 시스템
        8. 미세한 변화에도 출력 변화가 있게 되므로 신호 값이 연속적으로 처리되어 정확한 구분이 어려움
        9. 증폭 회로 사용
    2. 디지털 시스템
        1. 일정한 시간 단위로 끊어진 데이터
        2. 0과 1로 이뤄진 이진법 논리를 사용해 0과 1의 각종 조합을 만든 후 그것의 조작과 처리를 통해 여러 가지 정보를 생산, 유통, 전달할 수 있도록 만듦
        3. 현대에 사용되는 대부분의 정보 시스템에서 사용
        4. 압축 가능
        5. 일정 수준 이하의 훼손일 경우 100% 복원이 가능
        6. 측정 오차가 없이 정확도가 높아, 신뢰도가 높음
        7. 디지털 집적 회로의 제작이 용이하고 경제성이 높음
        8. 집적 회로의 발달로 저렴한 비용 고용량 저장이 가능
        9. 잡음에 강하고 손실이 거의 없음
        10. 논리 회로 사용
        11. 통신 및 자료처리, 자동제어, 의료기 분야에 이르기까지 다양하게 사용
        12. [HD방송을 고화질로 볼 수 있는 이유] : 방송 신호를 디지털 신호로 변경한 후 MPEG로 압축 전송하기 때문
    3. 아날로그 신호와 디지털 신호의 교환
        1. 아날로그 신호 처리 → A/D 컨버터 → 디지털 신호 처리
        2. 디지털 신호 처리 → D/A 컨버터 → 아날로그 신호 처리
2. 논리회로
    1. 컴퓨터는 0(거짓, off)과 1(참, on)이라는 두 가지 상태만을 다루는 2진법 체계인데, 내부의 회로들은 이런 두 상태 간의 어떤 논리에 의해 작동이 됨
    2. 2진 정보 체계로 작동되는 어떤 논리를 가진 회로를 논리회로라 하고, 그 구성소자로는 회로(gate)와 플립플롭(flip-flop)이 있다.
    3. 기본 논리 회로
        1. 논리를 가진 논리 회로의 기본 소자로서 기본 회로는 AND, OR, NOT 회로 3가지가 있으며 하나 더 추가시키면 NAND, NOR, XOR가 있다.
        2. AND(논리곱) 회로, 둘 다 참(1)일 때 결과도 참(1) - 기호, 논리식, 진리표 알아두기
        3. OR(논리합) 회로: 둘 중 하나가 참일 때 결과도 참
        4. NOT(부정) 회로: 참의 결과는 거짓, 거짓의 결과는 참
        5. NAND(논리곱 부정) 회로: 둘 다 참일 때, 결과는 거짓(0)
        6. NOR(논리합 부정) 회로: 둘 다 거짓일 때, 결과는 참

1. 진법과 연산 방법
    1. 진법과 변환
        1. 진법 
            1. 수를 표기하는 기수법의 하나로 임의의 숫자를 사용해 수를 표현하는 방법
            2. 일반적으로 사용하는 1부터 9까지의 숫자를 사용해 수를 나타내는 방법은 10진법이라 함
            3. 2진법
                1. 컴퓨터의 정보 표현 방법
                2. 0과 1, 두 개의 숫자만으로 수를 표현하는 방법
                3. 컴퓨터에서는 2진수의 한 자리를 비트라는 용어를 사용해 가리키며, 이런 비트가 8개가 모여 1바이트를 구성함
            4. 8진법
                1. 0~7, 8개의 숫자만으로 수를 표현하는 방법
                2. 2진수를 3자리씩 묶어서 표현할 수 있어, 초창기 컴퓨터에서 많이 사용
            5. 16진법
                1. 0~9의 숫자와 A~F까지의 문자를 함께 사용해 수를 표현하는 방법
                2. 2진수를 4자리씩 묶어서 표현할 수 있음
                3. 1개의 16진수는 4자리 2진수로 표현됨
                4. A~F의 문자는 10~15를 의미
            6. 진법 변환 
                1. 10진수를 각 진법으로 변환하는 방법
                    1. 10진값을 변환하고자 하는 기수로 나눔(2진법이면 2로 나눔)
                    2. 나눈 나머지를 기록 
                    3. 나눈 몫 < 기수 
                        1. yes - 마지막 몫과 지금까지 기록한 나머지들을 역으로 연결
                        2. no →나눈 몫을 변환하고자 하는 기수로 나눔
            7. Bit → Nibble(4 bit) → Byte(8bit) → Word(2 byte) → paragraph(16 byte) → Page(256 byte)
            8. MSB : 부호 비트 (양수 → 0, 음수 → 1)
            9. 진법 연산
                1. 덧셈 연산
                    1. 두 수의 자릿수를 맞춤(부족한 자리는 0으로 채움)
                    2. 맨 마지막 숫자끼리 더함
                    3. 더한 결과 몫 < 기수(2진법이라면 2가 기수)
                        1. yes : 결과 값의 현재 자리에 더한 결과를 기록
                            1. 결과값의 현재 자리에 더한 결과를 기록
                            2. 왼쪽으로 이동했을 때 숫자가 있는지?
                                1. yes : 더한 결과의 맨 왼쪽에 올림 수를 기록
                                2. no : 한 자리 이동한 자리의 숫자끼리 더한 값에 올림 수를 더함
                        2. no : 올림 수에 1을 기록
                            1. “더한 결과 - 기수”를 결과값의 현재 자리에 기록
                                1. 왼쪽으로 이동했을 때 숫자가 있는지?  - 이하 동일
                2. 뺄셈 연산
                    1. 가장 먼저 자릿수를 맞추는 것이 가장 중요
                    2. 2진수 음수를 표시하는 방법
                        1. 부호와 절대치 - 부호 비트를 제외한 값에 - 부호를 붙임
                        2. 1의 보수 - 부호 비트를 제외한 값에 1의 보수 : 0은 1로, 1은 0으로 바꾸고, -부호를 붙임
                        3. 2의 보수 - 부호 비트를 제외한 값의 1의 보수 + 1에, -부호를 붙임(가장 일반적으로 사용하는 방법)
                3. 2진수 음수의 3가지 표현
                    1. 8bit의 크기이며, 최상위 비트인 MBS가 부호 비트임
                    
                    | 2진수 | 부호와 절대치 | 1의 보수 | 2의 보수 |
                    | --- | --- | --- | --- |
                    | 10000000 | -0 | -127 | -128 |
                    | 10000001 | -1 | -126 | -127 |
                4. N진수 음수를 표시하는 방법
                    
                    
                    | 방법 | 설명 |
                    | --- | --- |
                    | 부호와 절대치 | 부호 비트를 제외한 값에 -부호를 붙임 |
                    | N-1의 보수 | 부호 비트를 제외한 값의 각 자리의 수를 “(N-1)-숫자”로 구함 |
                    | N의 보수 | (N-1)의 보수 + 1 |
                5. N진수 음수의 3가지 표현
                    
                    
                    | 진수 | 음수 | (N-1)의 보수 | N의 보수 |
                    | --- | --- | --- | --- |
                    | 8진수 | -15 | 77-15=62 | (77-15)+1=63 |
                    | 10진수 | -15 | 99-15=84 | (99-15)+1=85 |
                    | 16진수 | -15 | FF-15=FA | (FF-15)+1=EB |
                6. 수의 표현 방법: 부호 있는 1 Byte
                    1. 2의 8승 → 256개의 수
                7. overflow와 underflow의 발생 시점
                    1. 부호 없는 1바이트의 수
                        1. overflow : 덧셈 결과가 255보다 클 때
                        2. underflow  : 뺄셈 결과가 0보다 작을 때
                    2. 부호 있는 1바이트의 수
                    3. 부호 없는 2바이트의 수
                    4. 부호 있는 2바이트의 수

### Overflow와 Underflow는 어떤 경우에 발생하며, 이와 같은 상황이 발생하지 않게 왜 주의해야 할까요?

overflow는 양수를 표현할 수 있는 경계를 넘어섰을 때 발생하는 오류로 주로 덧셈 연산 시 발생합니다. underflow는 음수를 표현할 수 있는 경계를 넘어섰을 때 발생하는 오류로 주로 뺄셈 연산 시 발생합니다. 이와 같은 오류를 주의해야 하는 이유는 연산의 결과가 표현 범위를 넘을 때 주로 잘못된 계산 결과를 발생시키기 때문입니다. 마이크로프로세서에서는 이와 같은 상황이 발생했을 때 해당 플러그(flog)를 Set시킴으로써 경고 에러를 발생시킵니다.